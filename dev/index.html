<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · KPM</title><meta name="title" content="Home · KPM"/><meta property="og:title" content="Home · KPM"/><meta property="twitter:title" content="Home · KPM"/><meta name="description" content="Documentation for KPM."/><meta property="og:description" content="Documentation for KPM."/><meta property="twitter:description" content="Documentation for KPM."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>KPM</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-examples"><span>Quick examples</span></a></li><li class="toplevel"><a class="tocitem" href="#Moment-calculation"><span>Moment calculation</span></a></li><li class="toplevel"><a class="tocitem" href="#Applications"><span>Applications</span></a></li><li><a class="tocitem" href="#DOS"><span>DOS</span></a></li><li class="toplevel"><a class="tocitem" href="#Kernels"><span>Kernels</span></a></li><li><a class="tocitem" href="#API-overview"><span>API overview</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/angkunwu/KPMsub.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/angkunwu/KPMsub.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KPM"><a class="docs-heading-anchor" href="#KPM">KPM</a><a id="KPM-1"></a><a class="docs-heading-anchor-permalink" href="#KPM" title="Permalink"></a></h1><ul><li><a href="#KPM.JacksonKernel-Tuple{Integer, Integer}"><code>KPM.JacksonKernel</code></a></li><li><a href="#KPM.Lambda_nm-Tuple{Any, Any, Any}"><code>KPM.Lambda_nm</code></a></li><li><a href="#KPM.LorentzKernels-Tuple{Float64}"><code>KPM.LorentzKernels</code></a></li><li><a href="#KPM.broadcast_dot_1d_1d!"><code>KPM.broadcast_dot_1d_1d!</code></a></li><li><a href="#KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Union{SubArray, Array}, Vector{T} where T&lt;:(SubArray{Ts, 2} where Ts), Matrix, Int64, Int64}"><code>KPM.broadcast_dot_reduce_avg_2d_1d!</code></a></li><li><a href="#KPM.d_dc_cond"><code>KPM.d_dc_cond</code></a></li><li><a href="#KPM.dc_cond0-Tuple{Any, Number}"><code>KPM.dc_cond0</code></a></li><li><a href="#KPM.dc_cond0"><code>KPM.dc_cond0</code></a></li><li><a href="#KPM.dc_cond_single"><code>KPM.dc_cond_single</code></a></li><li><a href="#KPM.dc_cond_single-Tuple{Any, Number, Number}"><code>KPM.dc_cond_single</code></a></li><li><a href="#KPM.dos"><code>KPM.dos</code></a></li><li><a href="#KPM.dos0"><code>KPM.dos0</code></a></li><li><a href="#KPM.fermiFunction-Tuple{Float64, Float64, Float64}"><code>KPM.fermiFunction</code></a></li><li><a href="#KPM.fermiFunctions-Tuple{Float64, Float64}"><code>KPM.fermiFunctions</code></a></li><li><a href="#KPM.gram_schmidt-Tuple{Any}"><code>KPM.gram_schmidt</code></a></li><li><a href="#KPM.gram_schmidt!-Tuple{Any}"><code>KPM.gram_schmidt!</code></a></li><li><a href="#KPM.isNotBoundary-NTuple{4, Any}"><code>KPM.isNotBoundary</code></a></li><li><a href="#KPM.kpm_1d"><code>KPM.kpm_1d</code></a></li><li><a href="#KPM.kpm_1d!"><code>KPM.kpm_1d!</code></a></li><li><a href="#KPM.kpm_1d_current"><code>KPM.kpm_1d_current</code></a></li><li><a href="#KPM.kpm_1d_current!"><code>KPM.kpm_1d_current!</code></a></li><li><a href="#KPM.kpm_2d"><code>KPM.kpm_2d</code></a></li><li><a href="#KPM.kpm_2d!"><code>KPM.kpm_2d!</code></a></li><li><a href="#KPM.kpm_3d"><code>KPM.kpm_3d</code></a></li><li><a href="#KPM.kpm_3d!"><code>KPM.kpm_3d!</code></a></li><li><a href="#KPM.mu2D_apply_kernel_and_h_no_mutate-Tuple{Any, Int64, Function}"><code>KPM.mu2D_apply_kernel_and_h_no_mutate</code></a></li><li><a href="#KPM.normalizeH-Tuple{Any}"><code>KPM.normalizeH</code></a></li><li><a href="#KPM.normalize_by_col-Tuple{Any, Any}"><code>KPM.normalize_by_col</code></a></li><li><a href="#KPM.whichcore-Tuple{}"><code>KPM.whichcore</code></a></li><li><a href="#KPM.wrapAdd-Tuple{Int64, Int64, Int64}"><code>KPM.wrapAdd</code></a></li><li><a href="#KPM.Γnm-Tuple{Int64, Int64, Any}"><code>KPM.Γnm</code></a></li><li><a href="#KPM.Γnmμnmαβ-Tuple{Array, Any, Any}"><code>KPM.Γnmμnmαβ</code></a></li><li><a href="#KPM.Λn-Tuple{Any}"><code>KPM.Λn</code></a></li><li><a href="#KPM.Λnmp-Tuple{Any, Any, Any}"><code>KPM.Λnmp</code></a></li></ul><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is currently unregistered. Install the latest version directly from GitHub:</p><pre><code class="language-bash hljs">] add https://github.com/Pixley-Research-Group-in-CMT/KPM.jl</code></pre><p>Notes:</p><ul><li>The package supports CUDA.jl versions 4 and 5.</li><li>After installation import with:</li></ul><pre><code class="language-julia hljs">using KPM</code></pre><ul><li>To update the package run:</li></ul><pre><code class="language-bash hljs">] update KPM</code></pre><p>and provide your GitHub username/password if prompted.</p><p>For more details see the project&#39;s README.</p><h2 id="Quick-examples"><a class="docs-heading-anchor" href="#Quick-examples">Quick examples</a><a id="Quick-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-examples" title="Permalink"></a></h2><h3 id="1)-Density-of-States-(DOS)-—-concise-example"><a class="docs-heading-anchor" href="#1)-Density-of-States-(DOS)-—-concise-example">1) Density of States (DOS) — concise example</a><a id="1)-Density-of-States-(DOS)-—-concise-example-1"></a><a class="docs-heading-anchor-permalink" href="#1)-Density-of-States-(DOS)-—-concise-example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using KPM, LinearAlgebra, SparseArrays, Plots

# small 1D tight-binding (periodic)
function tb1dchain(N; t=1.0)
  H = spzeros(N,N)
  for i in 1:N-1
    H[i,i+1] = -t; H[i+1,i] = -t
  end
  H[1,N] = -t; H[N,1] = -t
  return H
end

N = 1000
NC = 256
NR = 4
H = tb1dchain(N)
# rescale H to (-1,1)
a, Hn = KPM.normalizeH(H)
mu = KPM.kpm_1d(Hn, NC, NR)
E, rho = KPM.dos(mu, a; kernel=KPM.JacksonKernel, N_tilde=500)

plot(E, rho, xlabel=&quot;E&quot;, ylabel=&quot;DOS&quot;, legend=false)</code></pre><p>Reference (full example):</p><pre><code class="language-julia hljs">using KPM
using LinearAlgebra
using SparseArrays

# Simple dense 1D tight-binding Hamiltonian (periodic)
function tb1dchain(N::Integer; t::Real=1.0)
    H = zeros(Float64, N, N)
    for i in 1:(N-1)
        H[i, i+1] = -t
        H[i+1, i] = -t
    end
    H[1, N] = -t
    H[N, 1] = -t
    return H
end

# Parameters
N = 1000               # system size
NC = 1024               # Chebyshev order
NR = 10               # number of random vectors for stochastic trace
nE = 1000             # output energy grid points

H = tb1dchain(N)
# Rescale H -&gt; (-1, 1)
#Hsparse = sparse(H.*(1+0*1im)) # make the Hamiltonian sparse under complex number
b, H_norm = KPM.normalizeH(H)

# Compute Chebyshev moments (DOS)
mu = KPM.kpm_1d(H_norm, NC, NR)    # returns moments (array-like)

# Reconstruct DOS on a grid and map energies back to physical scale
E, rho1024 = KPM.dos(mu, b;kernel = KPM.JacksonKernel, N_tilde=nE)
E, rho64 = KPM.dos(mu[1:64], b;kernel = KPM.JacksonKernel, N_tilde=nE)
E, rho32 = KPM.dos(mu[1:32], b;kernel = KPM.JacksonKernel, N_tilde=nE)

# Analytical DOS 
rho_exact = zeros(length(E))
mask = abs.(E) .&lt; 2
rho_exact[mask] = 1.0 ./ (π * sqrt.(4 .- E[mask].^2))

# plot the DOS
plot(xlabel=L&quot;E&quot;, ylabel=&quot;DOS&quot;*L&quot;\;\rho(E)&quot;,
        legend = :top, 
        #xlim=[-0.1,0.8586],ylim=[-0.001,0.035],
        framestyle = :box,grid=false,
        xtickfontsize=12, ytickfontsize=12,
        xguidefontsize=12, yguidefontsize=12,
        legendfontsize=12,
        )
plot!(E, [rho1024 rho64 rho32], lw=[4 3 2],label=[L&quot;N_C=1024&quot; L&quot;N_C=64&quot; L&quot;N_C=32&quot;])
plot!(E, rho_exact, c=:black, ls=:dash, label=L&quot;\mathrm{Analytic}&quot;)</code></pre><h3 id="2)-Optical-conductivity-(graphene)-—-concise-example"><a class="docs-heading-anchor" href="#2)-Optical-conductivity-(graphene)-—-concise-example">2) Optical conductivity (graphene) — concise example</a><a id="2)-Optical-conductivity-(graphene)-—-concise-example-1"></a><a class="docs-heading-anchor-permalink" href="#2)-Optical-conductivity-(graphene)-—-concise-example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using KPM, Plots
include(&quot;examples/GrapheneModel.jl&quot;) # provides GrapheneLattice

L = 60
Ham, Jx, Jy, Jxx, Jxy, Jyy = GrapheneLattice(L, L)
a = 3.5
Hn = Ham / a
NC = 256; NR = 6
mu2d = zeros(ComplexF64, NC, NC)
psi = exp.(2π*1im*rand(Hn.n, NR))
KPM.normalize_by_col(psi, NR)
KPM.kpm_2d!(Hn, Jy, Jy, NC, NR, Hn.n, mu2d, psi, psi)

# compute a sample optical conductivity (2D contribution) at ω=0.5
ω = 0.5
σ2 = KPM.d_optical_cond2(mu2d, NC, ω, 0.0)
println(&quot;Optical conductivity (2D part) at ω=&quot;, ω, &quot; : &quot;, σ2)</code></pre><p>Reference (full example):</p><pre><code class="language-julia hljs">using Plots
using LaTeXStrings
using KPM

include(&quot;GrapheneModel.jl&quot;) # Include the GrapheneLattice function and related structures

function full_optical_condT0(mu1d,mu2d, NC, ω; δ=1e-5, λ=0.0, kernel=KPM.JacksonKernel,
    h = 0.001, Emin= -0.8, Emax = 0.0
    )
    # This function is used to calculate the full optical conductivity
    # by combining the 1D and 2D contributions.
    x_all = collect(Emin:h:Emax)
    y_1 = zeros(ComplexF64, length(x_all))
    y_2 = zeros(ComplexF64, length(x_all))
    mu1d_dev = KPM.maybe_to_device(mu1d[1:NC])
    mu2d_dev = KPM.maybe_to_device(mu2d[1:NC, 1:NC])

    for (i, x) in enumerate(x_all)
        y_1[i] += KPM.d_optical_cond1(mu1d_dev, NC, x; δ=δ, λ=λ, kernel=kernel)
        y_2[i] += KPM.d_optical_cond2(mu2d_dev, NC, ω, x; δ=δ, λ=λ, kernel=kernel)
    end
    return (sum(y_1) * h * (-1im / ω), sum(y_2) * h * (-1im / ω))
    #y_all = y_1 .+ y_2;
    #y_integral = sum(y_all) * h;
    
    #return y_integral*(-1im / ω) # -ie^2 / (ħ^2 * ω)
end

L = 200
Ham, Jx, Jy,Jxx,Jxy,Jyy = GrapheneLattice(L,L);

a = 3.5
H_norm = Ham ./ a
NC = 512 #512
NR = 10
NH = H_norm.n
mu_2d_yy = zeros(ComplexF64, NC, NC)
psi_in_l = exp.(2pi * 1im * rand(NH, NR));
KPM.normalize_by_col(psi_in_l, NR)
psi_in_r = psi_in_l
@time KPM.kpm_2d!(H_norm, Jy, Jy, NC, NR, NH, mu_2d_yy, psi_in_l, psi_in_r; verbose=1);

mu_1d_yy = KPM.kpm_1d_current(H_norm,Jyy, NC, NR; verbose=1)

t = 2.3
μ = 0.466
Ef = μ/t/a
λ = 38.8*10^(-3)/t/a
ωs = collect(LinRange(0.03, 0.982, 100))
res = zeros(ComplexF64, length(ωs))
res2 = zeros(ComplexF64, length(ωs))
for (i, ω) in enumerate(ωs)
    res[i], res2[i] = full_optical_condT0(mu_1d_yy,mu_2d_yy, NC, ω;λ=λ,Emax=Ef)
    #res[i] = full_optical_condT0(mu_1d_yy,mu_2d_yy, NC, ω;λ=λ,Emax=Ef)
    println(i)
end
σyyreal = real.(res2)./a
σyyimag = imag.(t*a*res.+res2)./a
ωsreno = ωs*t*a

plot(ylabel = L&quot;\sigma^{yy}/\sigma_0&quot;,xlabel = L&quot;\hbar \omega(\mathrm{eV})&quot;,
     framestyle = :box,grid=false,legend=:topright,
        xtickfontsize=12, ytickfontsize=12,
        xguidefontsize=12, yguidefontsize=12,
        legendfontsize=12,#titlefontsize=12,
         ylim=(-2,8)
        )
scatter!(ωs*t*a, σyyreal, label=&quot;real&quot;,markerstrokewidth=0.0)
scatter!(ωs*t*a, σyyimag, label=&quot;imag&quot;,markerstrokewidth=0.0)</code></pre><h1 id="Moment-calculation"><a class="docs-heading-anchor" href="#Moment-calculation">Moment calculation</a><a id="Moment-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#Moment-calculation" title="Permalink"></a></h1><p>The first step in KPM is calculating moments using Hamiltonians (and current operators for conductivity, etc.). Functions with <code>!</code> are the more efficient in-place versions; functions without <code>!</code> are convenient wrappers that call the in-place implementations.</p><article><details class="docstring" open="true"><summary id="KPM.kpm_1d-index"><a class="docstring-binding" href="#KPM.kpm_1d-index"><code>KPM.kpm_1d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d(H, NC, NR; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L302"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:302</code></a>.</p><pre><code class="language-julia hljs">kpm_1d(
    H,
    NC,
    NR,
    NH;
    psi_in,
    psi_in_l,
    psi_in_r,
    force_norm,
    verbose,
    avg_output,
    NR_parallel
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L303"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:303</code></a>.</p><p>The simple version of 1D KPM that returns the moment.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix</p></li><li><p><code>NC</code>          – Integer. the cut off dimension</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian</p></li><li><p><code>psi_in</code>      – Optional. Allow setting random vector manually.</p></li><li><p><code>force_norm</code>  – Boolean, Optional. Apply normalization.</p></li><li><p><code>verbose</code>     – Integer. Default is 0. Enables progress bar if set <code>verbose=1</code>.</p></li><li><p><code>avg_output</code>  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_1d!-index"><a class="docstring-binding" href="#KPM.kpm_1d!-index"><code>KPM.kpm_1d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu_all, psi_in; verbose, α_all)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L364"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:364</code></a>.</p><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L426"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:426</code></a>.</p><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu, psi_in_l, psi_in_r; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L435"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:435</code></a>.</p><p>The in-place version of 1D KPM.  Calculate the moments μ defined in KPM. Output is saved in <code>mu</code>.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix.</p></li><li><p><code>NC</code>          – Integer. the cut off dimension.</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation.</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian.</p></li><li><p><code>mu_all</code>          – Array. Output for each random vector. Size (NR, NC). </p></li><li><p><code>psi_in</code>      – Array (optional). Input array on the right side. A ket.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_2d-index"><a class="docstring-binding" href="#KPM.kpm_2d-index"><code>KPM.kpm_2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_2d(
    H,
    Jα,
    Jβ,
    NC,
    NR,
    NH;
    psi_in,
    psi_in_l,
    psi_in_r,
    arr_size,
    moment_parity,
    verbose
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L595"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:595</code></a>.</p><p>The simple version of 2D KPM that returns the moment. Calculate moments for 2D KPM. </p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.</p><p>Output: μ, a 2D array in ComplexF64. μ[n, m] is the momentum for 2D KPM.</p><p><strong>ARGS</strong></p><ul><li><code>H</code></li></ul><p>Hamiltonian. A sparse 2D array.</p><ul><li><code>Jα</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>Jβ</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>NC</code></li></ul><p>Integer. KPM cutoff order.</p><ul><li><code>NR</code></li></ul><p>Integer. Number of random vectors to choose from. When skipped, understood as NR=1.</p><ul><li><code>NH</code></li></ul><p>Integer. Dimension of H, Jα and Jβ</p><p><strong>KWARGS</strong></p><ul><li><code>psi_in_l</code></li></ul><p>Passes value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in_r</code></li></ul><p>Passes value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in</code></li></ul><p>Cannot be used together with psi<em>in</em>l and psi<em>in</em>r. Sets psi<em>in</em>l=psi<em>in</em>r=psi_in if set.</p><ul><li><code>kwargs</code></li></ul><p>other kwargs in KPM_2D!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_2d!-index"><a class="docstring-binding" href="#KPM.kpm_2d!-index"><code>KPM.kpm_2d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_2d!(
    H,
    Jα,
    Jβ,
    NC,
    NR,
    NH,
    μ,
    psi_in_l,
    psi_in_r;
    arr_size,
    verbose,
    mn_sym,
    moment_parity,
    ψ0r,
    Jψ0r,
    JTnHJψr,
    ψall_r,
    ψ0l,
    ψall_l,
    ψw
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L618"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:618</code></a>.</p><pre><code class="language-julia hljs">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L755"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:755</code></a>.</p><pre><code class="language-julia hljs">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L765"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:765</code></a>.</p><p>In place KPM2D. This is also the main building block for KPM_2D. This method only provide NR=1.</p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>.  When <code>ψ0r</code> and <code>ψ0l</code> are chosen to be random and identical, the output approximates <code>tr(Tm(H) Jβ Tn(H) Jα)</code>. The accuracy is <span>$\sim O(1/sqrt(NR * NH))$</span> with NR repetitions. NC controls the energy resolution of the result.</p><p>Output: nothing. Result is saved on μ.</p><p><strong>ARGS</strong></p><ul><li><p><code>H</code> : Hamiltonian. A sparse 2D array.</p></li><li><p><code>Jα</code> : Current operator. A sparse 2D array.</p></li><li><p><code>Jβ</code> : Current operator. A sparse 2D array.</p></li><li><p><code>NC</code> : Integer. KPM cutoff order.</p></li><li><p><code>NR</code> : Integer. Number of random vectors.</p></li><li><p><code>NH</code> : Integer. Dimension of H, Jα and Jβ</p></li><li><p><code>μ</code> : 2D Array of dimension (NC, NC). Results will be updated here. Any data</p></li></ul><p>will be overwritten.</p><ul><li><code>psi_in</code> : Set <code>psi_in_l</code> and <code>psi_in_r</code>. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in</code> should be normalized.</p><ul><li><code>psi_in_l</code> : Passes value to ψ0l. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_l</code> should be normalized. <code>psi_in_l</code> is given as column vector of ket <span>$|ψl&gt; = &lt;ψl|^\dagger$</span></p><ul><li><code>psi_in_r</code> : Passes value to ψ0r. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_r</code> should be normalized. <code>psi_in_r</code> is given as column vector of ket <span>$|ψr&gt;$</span>. </p><p><strong>KWARGS</strong></p><ul><li><code>arr_size</code> : The buffer array size. Minimum is 3. Determines the number of</li></ul><p>left states to be kept in memory for each loop of right states. The time complexity is reduced from <span>$O(N\times NC^2)$</span> to <span>$O(N\times NC\times arr\_size)$</span> while space complexity is increased from <span>$O(N\times NC)$</span> to <span>$O(N\times NC\times arr\_size)$</span>.</p><ul><li><code>moment_parity</code> : The condition enforced on μmn. Choose from <code>:NONE</code>, <code>:ODD</code> and <code>:EVEN</code>.</li></ul><p><code>:NONE</code> will calculate all μmn; <code>:ODD</code> will calculate μmn such that <code>mod(m+n, 2)==1</code>; <code>:EVEN</code> will calculate μmn such that <code>mod(m+n, 2)==0</code>. As an example, <code>moment_parity=:EVEN</code> can be used when calculating longitudinal conductivity on model with particle-hole symmetry to save time and increase accuracy. </p><p><strong>working spaces KWARGS</strong>: The following keyword args are simply providing working place arrays to avoid repetitive allocation and GC. They are automatically created if not set. However, when using <code>KPM_2D!</code> for many times, it is beneficial to reuse those arrays.  CONVENTION: args with <code>ψ</code> are all working space arr.</p><ul><li><code>ψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>Jψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>JTnHJψr=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_r=maybe_on_device_zeros(3, NH, NR)</code></li><li><code>ψ0l=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_l=maybe_on_device_zeros(arr_size, NH, NR)</code></li><li><code>ψw=maybe_on_device_zeros(NH, NR)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L103">source</a></section></details></article><h1 id="Applications"><a class="docs-heading-anchor" href="#Applications">Applications</a><a id="Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Applications" title="Permalink"></a></h1><h2 id="DOS"><a class="docs-heading-anchor" href="#DOS">DOS</a><a id="DOS-1"></a><a class="docs-heading-anchor-permalink" href="#DOS" title="Permalink"></a></h2><p>To calculate the density of states (DOS) first calculate moments using <code>kpm_1d</code> / <code>kpm_1d!</code> with default (random) input vectors. Then use the returned moments (<code>mu</code>) to evaluate the DOS. There is also a convenience overload that accepts a Hamiltonian directly and performs the moment calculation for you via <code>dos</code>.</p><article><details class="docstring" open="true"><summary id="KPM.dos-index"><a class="docstring-binding" href="#KPM.dos-index"><code>KPM.dos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dos(
    H;
    NC,
    NR,
    E_grid,
    N_tilde,
    E_range,
    kernel,
    fix_normalization,
    dE_order
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/dos.jl#L31"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:31</code></a>.</p><pre><code class="language-julia hljs">dos(
    μ,
    H_rescale_factor;
    E_grid,
    N_tilde,
    E_range,
    NC,
    kernel,
    dE_order
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/dos.jl#L49"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:49</code></a>.</p><p>Calculate DOS for a fermi energy grid spanning <code>E_range</code> with <code>N_tilde</code> total points. If <code>E_range</code> is not set,  automatically set it to be sightly smaller than full size. Otherwise an explicit array of <code>E_grid</code> can be passed in. Don&#39;t do both.</p><p>Either a) pass in a 1d array as moment and  as normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword <code>rescale_factor</code> that default to 1.</p><ul><li><p><code>H_rescale_factor</code> is the normalization of H. Needed when μ is passed.</p></li><li><p><code>NR</code> random vectors. Needed when H is passed</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dos.jl#L5">source</a></section></details></article><h1 id="Kernels"><a class="docs-heading-anchor" href="#Kernels">Kernels</a><a id="Kernels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernels" title="Permalink"></a></h1><p>Kernels are functions with signature</p><pre><code class="nohighlight hljs">kernel(n::Int64, N::Int64) -&gt; Float64</code></pre><p>such that when <code>n == 0</code> the kernel returns <code>1</code>, and when <code>n == N-1</code> it returns a small number close to <code>0</code>.</p><p>The package provides the <code>JacksonKernel</code> (the default for most applications) and <code>LorentzKernels</code>.</p><article><details class="docstring" open="true"><summary id="KPM.JacksonKernel-index"><a class="docstring-binding" href="#KPM.JacksonKernel-index"><code>KPM.JacksonKernel</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>JacksonKernel(n::Integer, N::Integer)</p><p>Jacksonkernel evaluated at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/kernels/jackson_kernel.jl#L2-L6">source</a></section></details></article><p>The Lorentz kernel is useful for Green&#39;s functions because it preserves certain symmetries. <code>LorentzKernels(λ)</code> returns a kernel function parameterized by λ.</p><article><details class="docstring" open="true"><summary id="KPM.LorentzKernels-index"><a class="docstring-binding" href="#KPM.LorentzKernels-index"><code>KPM.LorentzKernels</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>LorentzKernels(λ::Float64)</p><p>Returns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/kernels/lorentz_kernel.jl#L2-L6">source</a></section></details></article><h2 id="API-overview"><a class="docs-heading-anchor" href="#API-overview">API overview</a><a id="API-overview-1"></a><a class="docs-heading-anchor-permalink" href="#API-overview" title="Permalink"></a></h2><p>Below is a concise list of the main public APIs provided by the package.</p><ul><li><p>Moment / KPM core:</p><ul><li><code>kpm_1d</code>, <code>kpm_1d!</code></li><li><code>kpm_1d_current</code>, <code>kpm_1d_current!</code></li><li><code>kpm_2d</code>, <code>kpm_2d!</code></li><li><code>kpm_3d</code>, <code>kpm_3d!</code></li></ul></li><li><p>DOS / LDOS:</p><ul><li><code>dos</code>, <code>dos0</code></li><li><code>ldos_mu</code></li></ul></li><li><p>Conductivity (DC / optical):</p><ul><li><code>d_dc_cond</code>, <code>dc_cond0</code>, <code>dc_cond_single</code></li><li><code>optical_cond1</code>, <code>d_optical_cond1</code></li><li><code>optical_cond2</code>, <code>d_optical_cond2</code></li></ul></li><li><p>Nonlinear / CPGE:</p><ul><li><code>cpge</code>, <code>d_cpge</code></li><li>Integration helpers: <code>Λnmp</code>, <code>Λn</code>, <code>Λnm</code>, <code>gn_R</code>, <code>gn_A</code>, <code>Δn</code></li></ul></li><li><p>Kernels:</p><ul><li><code>JacksonKernel</code>, <code>LorentzKernels</code></li></ul></li><li><p>Utilities (KPM.Utils / device helpers):</p><ul><li><code>wrapAdd</code>, <code>normalizeH</code>, <code>isNotBoundary</code>, <code>timestamp</code></li><li>device helpers: <code>whichcore</code>, <code>maybe_to_device</code>, <code>maybe_to_host</code>, <code>maybe_on_device_rand</code>, <code>maybe_on_device_zeros</code></li></ul></li></ul><p>For more details see the full API reference below.</p><article><details class="docstring" open="true"><summary id="KPM.JacksonKernel-Tuple{Integer, Integer}"><a class="docstring-binding" href="#KPM.JacksonKernel-Tuple{Integer, Integer}"><code>KPM.JacksonKernel</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>JacksonKernel(n::Integer, N::Integer)</p><p>Jacksonkernel evaluated at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/kernels/jackson_kernel.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.Lambda_nm-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#KPM.Lambda_nm-Tuple{Any, Any, Any}"><code>KPM.Lambda_nm</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>Lambda_nm</code> is integral of f(Ef)/(1-Ef^2)^2 * Γnm(Ef). Notice that all Ef is scaled to -1 to 1.</p><p>δ is the amount around ±1 to avoid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dc_cond_util.jl#L56-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.LorentzKernels-Tuple{Float64}"><a class="docstring-binding" href="#KPM.LorentzKernels-Tuple{Float64}"><code>KPM.LorentzKernels</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>LorentzKernels(λ::Float64)</p><p>Returns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/kernels/lorentz_kernel.jl#L2-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.broadcast_dot_1d_1d!"><a class="docstring-binding" href="#KPM.broadcast_dot_1d_1d!"><code>KPM.broadcast_dot_1d_1d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Vl and Vr are both [NH, NR] sized array. Each corresponding [:, NR] slice pair is dotted, saving into the target of [NR], multiplying by alpha and plus beta. Beta is either a number or vector of [NR]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/vectors.jl#L88-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Union{SubArray, Array}, Vector{T} where T&lt;:(SubArray{Ts, 2} where Ts), Matrix, Int64, Int64}"><a class="docstring-binding" href="#KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Union{SubArray, Array}, Vector{T} where T&lt;:(SubArray{Ts, 2} where Ts), Matrix, Int64, Int64}"><code>KPM.broadcast_dot_reduce_avg_2d_1d!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Dot product each column of Vls with vector Vr, save in target. Each view has NR replica of NH. This function take the average.</p><p>target: 1D Array (n), n &gt;= NCcols. Vls: 1D Array of 2D views, shape (n), each view (NH, NR), where n &gt;= NCcols. Vr: 2D Array, shape NH, NR NCcols: Integer, number of columns. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/vectors.jl#L54-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.d_dc_cond"><a class="docstring-binding" href="#KPM.d_dc_cond"><code>KPM.d_dc_cond</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">d_dc_cond(μ, a, E; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/conductivity.jl#L82"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:82</code></a>.</p><pre><code class="language-julia hljs">d_dc_cond(μ, a, E; NC, kernel, dE_order)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/conductivity.jl#L84"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:84</code></a>.</p><p>Calculate the integrand for conductivity of an energy grid spanning <code>E_range</code> with <code>N_tilde</code> total points.  If <code>E_range</code> is not set,  automatically set it to be sightly smaller than full size.  Otherwise an explicit array of <code>E_grid</code> can be passed in. Don&#39;t do both.</p><p>Either a) pass in a 2d array as moment and a normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword <code>rescale_factor</code> that default to 1, as well as two current operators Jα and Jβ</p><ul><li><p><code>H_rescale_factor</code> is the normalization of H. Needed when μ is passed.</p></li><li><p><code>NR</code> random vectors. Needed when H is passed</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/conductivity.jl#L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dc_cond0"><a class="docstring-binding" href="#KPM.dc_cond0"><code>KPM.dc_cond0</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dc_cond0(mu, H_rescale_factor; kernel, NC)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/conductivity.jl#L127"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:127</code></a>.</p><p>Calculate DOS and its energy derivatives (by setting <code>dE_order</code>) at zero energy.</p><p>Warning: This method does not have correct normalization at the moment. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/conductivity.jl#L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dc_cond0-Tuple{Any, Number}"><a class="docstring-binding" href="#KPM.dc_cond0-Tuple{Any, Number}"><code>KPM.dc_cond0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>calculate conductivity for EF=0. Only works for longitudinal cond. Garcia et. al. Supp eq.25.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/conductivity.jl#L123-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dc_cond_single"><a class="docstring-binding" href="#KPM.dc_cond_single"><code>KPM.dc_cond_single</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dc_cond_single(mu, H_rescale_factor, Ef; kernel, NC)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/conductivity.jl#L139"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:139</code></a>.</p><p>Calculate DOS at a given energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/conductivity.jl#L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dc_cond_single-Tuple{Any, Number, Number}"><a class="docstring-binding" href="#KPM.dc_cond_single-Tuple{Any, Number, Number}"><code>KPM.dc_cond_single</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>calculate conductivity for arbitrary EF. Only works for longitudinal cond. Garcia et. al. Supp eq.25.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/conductivity.jl#L135-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dos"><a class="docstring-binding" href="#KPM.dos"><code>KPM.dos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dos(
    H;
    NC,
    NR,
    E_grid,
    N_tilde,
    E_range,
    kernel,
    fix_normalization,
    dE_order
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/dos.jl#L31"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:31</code></a>.</p><pre><code class="language-julia hljs">dos(
    μ,
    H_rescale_factor;
    E_grid,
    N_tilde,
    E_range,
    NC,
    kernel,
    dE_order
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/dos.jl#L49"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:49</code></a>.</p><p>Calculate DOS for a fermi energy grid spanning <code>E_range</code> with <code>N_tilde</code> total points. If <code>E_range</code> is not set,  automatically set it to be sightly smaller than full size. Otherwise an explicit array of <code>E_grid</code> can be passed in. Don&#39;t do both.</p><p>Either a) pass in a 1d array as moment and  as normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword <code>rescale_factor</code> that default to 1.</p><ul><li><p><code>H_rescale_factor</code> is the normalization of H. Needed when μ is passed.</p></li><li><p><code>NR</code> random vectors. Needed when H is passed</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dos.jl#L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.dos0"><a class="docstring-binding" href="#KPM.dos0"><code>KPM.dos0</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dos0(μ, H_rescale_factor; NC, kernel, dE_order)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/applications/dos.jl#L136"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:136</code></a>.</p><p>Calculate DOS and its energy derivatives (by setting <code>dE_order</code>) at zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dos.jl#L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.fermiFunction-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#KPM.fermiFunction-Tuple{Float64, Float64, Float64}"><code>KPM.fermiFunction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fermiFunction(E, E_f, beta)</code></pre><p>calculate Fermi-Dirac function at energy E, Fermi energy μ and temperature β =1/T. Input and output all Float64. Infinite β only allowed when accessing fermi energy through fermiFunctions(). [For performance reason for now. TODO: allow β=Inf here withouth perf. reduction. ]</p><p>Allow sloppy use of type as long as convertion is available, if using keyword arguments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/physics.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.fermiFunctions-Tuple{Float64, Float64}"><a class="docstring-binding" href="#KPM.fermiFunctions-Tuple{Float64, Float64}"><code>KPM.fermiFunctions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fermiFunctions(E_f::Float64, beta::Float64)</code></pre><p>returns a fermi function with given E_f and beta. </p><p>Allow sloppy use of type as long as convertion is available, if using keyword arguments. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/physics.jl#L21-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.gram_schmidt!-Tuple{Any}"><a class="docstring-binding" href="#KPM.gram_schmidt!-Tuple{Any}"><code>KPM.gram_schmidt!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>orthonormalize the column vectors of <code>A</code>. In-place.</p><p>Using classical Gram-Schmit.</p><p>When orthogonality is extremely important, applying the same method twice may help, according to <a href="http://stoppels.blog/posts/orthogonalization-performance">this note</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/vectors.jl#L19-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.gram_schmidt-Tuple{Any}"><a class="docstring-binding" href="#KPM.gram_schmidt-Tuple{Any}"><code>KPM.gram_schmidt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>orthonormalize the column vectors of <code>A</code>. See <code>gram_schmidt!</code>, the in-place version for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/vectors.jl#L43-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.isNotBoundary-NTuple{4, Any}"><a class="docstring-binding" href="#KPM.isNotBoundary-NTuple{4, Any}"><code>KPM.isNotBoundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>give 0 for OBC=1 direction if i,i_ is on boundary. Otherwise 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/external.jl#L11-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_1d"><a class="docstring-binding" href="#KPM.kpm_1d"><code>KPM.kpm_1d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d(H, NC, NR; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L302"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:302</code></a>.</p><pre><code class="language-julia hljs">kpm_1d(
    H,
    NC,
    NR,
    NH;
    psi_in,
    psi_in_l,
    psi_in_r,
    force_norm,
    verbose,
    avg_output,
    NR_parallel
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L303"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:303</code></a>.</p><p>The simple version of 1D KPM that returns the moment.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix</p></li><li><p><code>NC</code>          – Integer. the cut off dimension</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian</p></li><li><p><code>psi_in</code>      – Optional. Allow setting random vector manually.</p></li><li><p><code>force_norm</code>  – Boolean, Optional. Apply normalization.</p></li><li><p><code>verbose</code>     – Integer. Default is 0. Enables progress bar if set <code>verbose=1</code>.</p></li><li><p><code>avg_output</code>  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_1d!"><a class="docstring-binding" href="#KPM.kpm_1d!"><code>KPM.kpm_1d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu_all, psi_in; verbose, α_all)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L364"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:364</code></a>.</p><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L426"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:426</code></a>.</p><pre><code class="language-julia hljs">kpm_1d!(H, NC, NR, NH, mu, psi_in_l, psi_in_r; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L435"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:435</code></a>.</p><p>The in-place version of 1D KPM.  Calculate the moments μ defined in KPM. Output is saved in <code>mu</code>.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix.</p></li><li><p><code>NC</code>          – Integer. the cut off dimension.</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation.</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian.</p></li><li><p><code>mu_all</code>          – Array. Output for each random vector. Size (NR, NC). </p></li><li><p><code>psi_in</code>      – Array (optional). Input array on the right side. A ket.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_1d_current"><a class="docstring-binding" href="#KPM.kpm_1d_current"><code>KPM.kpm_1d_current</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d_current(H, Jα, NC, NR; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L445"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:445</code></a>.</p><pre><code class="language-julia hljs">kpm_1d_current(
    H,
    Jα,
    NC,
    NR,
    NH;
    psi_in,
    psi_in_l,
    psi_in_r,
    force_norm,
    verbose,
    avg_output,
    NR_parallel
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L446"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:446</code></a>.</p><p>The simple version of 1D KPM with current operator that returns the moment. Calculate moments Γ<em>n^α = Tr[J</em>α T_n(H)].</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix</p></li><li><p><code>Jα</code>          – Current operator. A matrix or sparse matrix</p></li><li><p><code>NC</code>          – Integer. the cut off dimension</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian</p></li><li><p><code>psi_in</code>      – Optional. Allow setting random vector manually.</p></li><li><p><code>force_norm</code>  – Boolean, Optional. Apply normalization.</p></li><li><p><code>verbose</code>     – Integer. Default is 0. Enables progress bar if set <code>verbose=1</code>.</p></li><li><p><code>avg_output</code>  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_1d_current!"><a class="docstring-binding" href="#KPM.kpm_1d_current!"><code>KPM.kpm_1d_current!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_1d_current!(
    H,
    Jα,
    NC,
    NR,
    NH,
    mu_all,
    psi_in;
    verbose,
    α_all,
    Jα_psi
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L507"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:507</code></a>.</p><pre><code class="language-julia hljs">kpm_1d_current!(H, Jα, NC, NR, NH, mu; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L570"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:570</code></a>.</p><pre><code class="language-julia hljs">kpm_1d_current!(
    H,
    Jα,
    NC,
    NR,
    NH,
    mu,
    psi_in_l,
    psi_in_r;
    kwargs...
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L580"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:580</code></a>.</p><p>The in-place version of 1D KPM with current operator. Calculate the moments μ defined in KPM: Γ<em>n^α = Tr[J</em>α T_n(H)].  Output is saved in <code>mu</code>.</p><ul><li><p><code>H</code>           – Hamiltonian. A matrix or sparse matrix.</p></li><li><p><code>Jα</code>          – Current operator. A matrix or sparse matrix.</p></li><li><p><code>NC</code>          – Integer. the cut off dimension.</p></li><li><p><code>NR</code>          – Integer. number of random vectors used for KPM evaluation.</p></li><li><p><code>NH</code>          – Integer. the size of hamiltonian.</p></li><li><p><code>mu_all</code>      – Array. Output for each random vector. Size (NR, NC). </p></li><li><p><code>psi_in</code>      – Array (optional). Input array on the right side. A ket.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_2d"><a class="docstring-binding" href="#KPM.kpm_2d"><code>KPM.kpm_2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_2d(
    H,
    Jα,
    Jβ,
    NC,
    NR,
    NH;
    psi_in,
    psi_in_l,
    psi_in_r,
    arr_size,
    moment_parity,
    verbose
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L595"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:595</code></a>.</p><p>The simple version of 2D KPM that returns the moment. Calculate moments for 2D KPM. </p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.</p><p>Output: μ, a 2D array in ComplexF64. μ[n, m] is the momentum for 2D KPM.</p><p><strong>ARGS</strong></p><ul><li><code>H</code></li></ul><p>Hamiltonian. A sparse 2D array.</p><ul><li><code>Jα</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>Jβ</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>NC</code></li></ul><p>Integer. KPM cutoff order.</p><ul><li><code>NR</code></li></ul><p>Integer. Number of random vectors to choose from. When skipped, understood as NR=1.</p><ul><li><code>NH</code></li></ul><p>Integer. Dimension of H, Jα and Jβ</p><p><strong>KWARGS</strong></p><ul><li><code>psi_in_l</code></li></ul><p>Passes value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in_r</code></li></ul><p>Passes value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in</code></li></ul><p>Cannot be used together with psi<em>in</em>l and psi<em>in</em>r. Sets psi<em>in</em>l=psi<em>in</em>r=psi_in if set.</p><ul><li><code>kwargs</code></li></ul><p>other kwargs in KPM_2D!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_2d!"><a class="docstring-binding" href="#KPM.kpm_2d!"><code>KPM.kpm_2d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_2d!(
    H,
    Jα,
    Jβ,
    NC,
    NR,
    NH,
    μ,
    psi_in_l,
    psi_in_r;
    arr_size,
    verbose,
    mn_sym,
    moment_parity,
    ψ0r,
    Jψ0r,
    JTnHJψr,
    ψall_r,
    ψ0l,
    ψall_l,
    ψw
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L618"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:618</code></a>.</p><pre><code class="language-julia hljs">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L755"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:755</code></a>.</p><pre><code class="language-julia hljs">kpm_2d!(H, Jα, Jβ, NC, NR, NH, μ; kwargs...)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L765"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:765</code></a>.</p><p>In place KPM2D. This is also the main building block for KPM_2D. This method only provide NR=1.</p><p>Calculates <code>ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r</code>.  When <code>ψ0r</code> and <code>ψ0l</code> are chosen to be random and identical, the output approximates <code>tr(Tm(H) Jβ Tn(H) Jα)</code>. The accuracy is <span>$\sim O(1/sqrt(NR * NH))$</span> with NR repetitions. NC controls the energy resolution of the result.</p><p>Output: nothing. Result is saved on μ.</p><p><strong>ARGS</strong></p><ul><li><p><code>H</code> : Hamiltonian. A sparse 2D array.</p></li><li><p><code>Jα</code> : Current operator. A sparse 2D array.</p></li><li><p><code>Jβ</code> : Current operator. A sparse 2D array.</p></li><li><p><code>NC</code> : Integer. KPM cutoff order.</p></li><li><p><code>NR</code> : Integer. Number of random vectors.</p></li><li><p><code>NH</code> : Integer. Dimension of H, Jα and Jβ</p></li><li><p><code>μ</code> : 2D Array of dimension (NC, NC). Results will be updated here. Any data</p></li></ul><p>will be overwritten.</p><ul><li><code>psi_in</code> : Set <code>psi_in_l</code> and <code>psi_in_r</code>. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in</code> should be normalized.</p><ul><li><code>psi_in_l</code> : Passes value to ψ0l. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_l</code> should be normalized. <code>psi_in_l</code> is given as column vector of ket <span>$|ψl&gt; = &lt;ψl|^\dagger$</span></p><ul><li><code>psi_in_r</code> : Passes value to ψ0r. Size is (NH, NR). The array is not updated.</li></ul><p>Whether the input is normalized or not, it is assumed to be intended. Usually <code>psi_in_r</code> should be normalized. <code>psi_in_r</code> is given as column vector of ket <span>$|ψr&gt;$</span>. </p><p><strong>KWARGS</strong></p><ul><li><code>arr_size</code> : The buffer array size. Minimum is 3. Determines the number of</li></ul><p>left states to be kept in memory for each loop of right states. The time complexity is reduced from <span>$O(N\times NC^2)$</span> to <span>$O(N\times NC\times arr\_size)$</span> while space complexity is increased from <span>$O(N\times NC)$</span> to <span>$O(N\times NC\times arr\_size)$</span>.</p><ul><li><code>moment_parity</code> : The condition enforced on μmn. Choose from <code>:NONE</code>, <code>:ODD</code> and <code>:EVEN</code>.</li></ul><p><code>:NONE</code> will calculate all μmn; <code>:ODD</code> will calculate μmn such that <code>mod(m+n, 2)==1</code>; <code>:EVEN</code> will calculate μmn such that <code>mod(m+n, 2)==0</code>. As an example, <code>moment_parity=:EVEN</code> can be used when calculating longitudinal conductivity on model with particle-hole symmetry to save time and increase accuracy. </p><p><strong>working spaces KWARGS</strong>: The following keyword args are simply providing working place arrays to avoid repetitive allocation and GC. They are automatically created if not set. However, when using <code>KPM_2D!</code> for many times, it is beneficial to reuse those arrays.  CONVENTION: args with <code>ψ</code> are all working space arr.</p><ul><li><code>ψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>Jψ0r=maybe_on_device_zeros(NH, NR)</code></li><li><code>JTnHJψr=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_r=maybe_on_device_zeros(3, NH, NR)</code></li><li><code>ψ0l=maybe_on_device_zeros(NH, NR)</code></li><li><code>ψall_l=maybe_on_device_zeros(arr_size, NH, NR)</code></li><li><code>ψw=maybe_on_device_zeros(NH, NR)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_3d"><a class="docstring-binding" href="#KPM.kpm_3d"><code>KPM.kpm_3d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_3d(
    H,
    Jα,
    Jβ,
    Jγ,
    NC,
    NR,
    NH;
    arr_size,
    verbose,
    psi_in_l,
    psi_in_r,
    psi_in
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L867"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:867</code></a>.</p><p>TODO: add doc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.kpm_3d!"><a class="docstring-binding" href="#KPM.kpm_3d!"><code>KPM.kpm_3d!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpm_3d!(
    H,
    Jα,
    Jβ,
    Jγ,
    NC,
    NR,
    NH,
    μ,
    psi_in_l,
    psi_in_r;
    arr_size,
    verbose,
    ψ0r,
    JTn1HJψr,
    ψall_r,
    ψ0l,
    sub_ψ0r,
    sub_Jψ0r,
    sub_JTnHJψr,
    sub_ψall_r,
    sub_ψ0l,
    sub_ψall_l,
    sub_ψw
)</code></pre><p>defined at <a href="https://github.com/angkunwu/KPMsub.jl/tree/ff2c1c4066519d64493b36a1026cd61984b187d4//src/moment.jl#L781"><code>/home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:781</code></a>.</p><p>The simple version of tripple KPM that returns the moment. Calculate moments for tripple KPM. </p><p>Calculates <code>ψ0l * Tn3(H) * Jγ * Tn2(H) * Jβ * Tn1(H) * Jα * ψ0r</code>. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tn3(H) Jγ Tn2(H) Jβ Tn1(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.</p><p>Output: μ, a 3D array in ComplexF64. μ[n3, n2, n1] is the momentum for 2D KPM.</p><p><strong>ARGS</strong></p><ul><li><code>H</code></li></ul><p>Hamiltonian. A sparse 2D array.</p><ul><li><code>Jα</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>Jβ</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>Jγ</code></li></ul><p>Current operator. A sparse 2D array.</p><ul><li><code>NC</code></li></ul><p>Integer. KPM cutoff order.</p><ul><li><code>NR</code></li></ul><p>Integer. Number of random vectors to choose from. When skipped, understood as NR=1.</p><ul><li><code>NH</code></li></ul><p>Integer. Dimension of H, Jα, Jβ and Jγ</p><p><strong>KWARGS</strong></p><ul><li><code>psi_in_l</code></li></ul><p>Passes value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in_r</code></li></ul><p>Passes value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.</p><ul><li><code>psi_in</code></li></ul><p>Cannot be used together with psi<em>in</em>l and psi<em>in</em>r. Sets psi<em>in</em>l=psi<em>in</em>r=psi_in if set.</p><ul><li><code>kwargs</code></li></ul><p>other kwargs in KPM_2D!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/moment.jl#L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.mu2D_apply_kernel_and_h_no_mutate-Tuple{Any, Int64, Function}"><a class="docstring-binding" href="#KPM.mu2D_apply_kernel_and_h_no_mutate-Tuple{Any, Int64, Function}"><code>KPM.mu2D_apply_kernel_and_h_no_mutate</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create μtilde based on mu, by applying both kernel function and hn(n) for each direction.</p><p>μtilde is ComplexF64 array.</p><p>No mutate version, takes more memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/kernels/kernels.jl#L42-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.normalizeH-Tuple{Any}"><a class="docstring-binding" href="#KPM.normalizeH-Tuple{Any}"><code>KPM.normalizeH</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Normalize H. If requested, allow renormalizing it to fixed value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/external.jl#L20-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.normalize_by_col-Tuple{Any, Any}"><a class="docstring-binding" href="#KPM.normalize_by_col-Tuple{Any, Any}"><code>KPM.normalize_by_col</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Normalize a collection of vectors in an (NH, NR) array <code>psi_in</code>, where each column (that is <code>psi_in[:, NRi]</code>) represent a separate vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/vectors.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.whichcore-Tuple{}"><a class="docstring-binding" href="#KPM.whichcore-Tuple{}"><code>KPM.whichcore</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Report whether GPU support is active.</p><p>Base package defaults to CPU-only behavior; CUDA-specific activation is provided by the optional package extension in <code>ext/KPMCUDAExt.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/device.jl#L17-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.wrapAdd-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#KPM.wrapAdd-Tuple{Int64, Int64, Int64}"><code>KPM.wrapAdd</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>wrapAdd find the sum of x and y, with L+1=1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/utils/external.jl#L3-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.Γnm-Tuple{Int64, Int64, Any}"><a class="docstring-binding" href="#KPM.Γnm-Tuple{Int64, Int64, Any}"><code>KPM.Γnm</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate Γnm. Details see Garcia et.al, PRL 114, 116602 (2015)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dc_cond_util.jl#L7-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.Γnmμnmαβ-Tuple{Array, Any, Any}"><a class="docstring-binding" href="#KPM.Γnmμnmαβ-Tuple{Array, Any, Any}"><code>KPM.Γnmμnmαβ</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate Γnmμnmαβ. The input μtilde should be the moment that has already applied kernel and hn</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/dc_cond_util.jl#L16-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.Λn-Tuple{Any}"><a class="docstring-binding" href="#KPM.Λn-Tuple{Any}"><code>KPM.Λn</code></a> — <span class="docstring-category">Method</span></summary><section><div><ul><li><p>beta : Inf is zero temperature. beta = 1/T.</p></li><li><p>E_f : Fermi energy. Between -1 and 1 because Hamiltonian is normalized. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/optical_cond.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="KPM.Λnmp-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#KPM.Λnmp-Tuple{Any, Any, Any}"><code>KPM.Λnmp</code></a> — <span class="docstring-category">Method</span></summary><section><div><ul><li><p>beta : Inf is zero temperature. beta = 1/T.</p></li><li><p>E_f : Fermi energy. Between -1 and 1 because Hamiltonian is normalized. </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/angkunwu/KPMsub.jl/blob/ff2c1c4066519d64493b36a1026cd61984b187d4/src/applications/cpge.jl#L42-L46">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 13 February 2026 19:22">Friday 13 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
