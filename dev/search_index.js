var documenterSearchIndex = {"docs":
[{"location":"#KPM","page":"Home","title":"KPM","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"This package is currently unregistered. Install the latest version directly from GitHub:\n\n] add https://github.com/Pixley-Research-Group-in-CMT/KPM.jl\n\nNotes:\n\nThe package supports CUDA.jl versions 4 and 5.\nAfter installation import with:\n\nusing KPM\n\nTo update the package run:\n\n] update KPM\n\nand provide your GitHub username/password if prompted.\n\nFor more details see the project's README.","category":"section"},{"location":"#Quick-examples","page":"Home","title":"Quick examples","text":"","category":"section"},{"location":"#1)-Density-of-States-(DOS)-—-concise-example","page":"Home","title":"1) Density of States (DOS) — concise example","text":"using KPM, LinearAlgebra, SparseArrays, Plots\n\n# small 1D tight-binding (periodic)\nfunction tb1dchain(N; t=1.0)\n  H = spzeros(N,N)\n  for i in 1:N-1\n    H[i,i+1] = -t; H[i+1,i] = -t\n  end\n  H[1,N] = -t; H[N,1] = -t\n  return H\nend\n\nN = 1000\nNC = 256\nNR = 4\nH = tb1dchain(N)\n# rescale H to (-1,1)\na, Hn = KPM.normalizeH(H)\nmu = KPM.kpm_1d(Hn, NC, NR)\nE, rho = KPM.dos(mu, a; kernel=KPM.JacksonKernel, N_tilde=500)\n\nplot(E, rho, xlabel=\"E\", ylabel=\"DOS\", legend=false)\nsavefig(\"docs/dos_example.pdf\")\n\nReference (full example):\n\nusing KPM\nusing LinearAlgebra\nusing SparseArrays\n\n# Simple dense 1D tight-binding Hamiltonian (periodic)\nfunction tb1dchain(N::Integer; t::Real=1.0)\n    H = zeros(Float64, N, N)\n    for i in 1:(N-1)\n        H[i, i+1] = -t\n        H[i+1, i] = -t\n    end\n    H[1, N] = -t\n    H[N, 1] = -t\n    return H\nend","category":"section"},{"location":"#2)-Optical-conductivity-(graphene)-—-concise-example","page":"Home","title":"2) Optical conductivity (graphene) — concise example","text":"using KPM, Plots\ninclude(\"examples/GrapheneModel.jl\") # provides GrapheneLattice\n\nL = 60\nHam, Jx, Jy, Jxx, Jxy, Jyy = GrapheneLattice(L, L)\na = 3.5\nHn = Ham / a\nNC = 256; NR = 6\nmu2d = zeros(ComplexF64, NC, NC)\npsi = exp.(2π*1im*rand(Hn.n, NR))\nKPM.normalize_by_col(psi, NR)\nKPM.kpm_2d!(Hn, Jy, Jy, NC, NR, Hn.n, mu2d, psi, psi)\n\n# compute a sample optical conductivity (2D contribution) at ω=0.5\nω = 0.5\nσ2 = KPM.d_optical_cond2(mu2d, NC, ω, 0.0)\nprintln(\"Optical conductivity (2D part) at ω=\", ω, \" : \", σ2)\n\nReference (full example):\n\nusing Plots\nusing LaTeXStrings\nusing KPM\n\ninclude(\"GrapheneModel.jl\") # Include the GrapheneLattice function and related structures\n\nfunction full_optical_condT0(mu1d,mu2d, NC, ω; δ=1e-5, λ=0.0, kernel=KPM.JacksonKernel,\n    h = 0.001, Emin= -0.8, Emax = 0.0\n    )\n    # This function is used to calculate the full optical conductivity\n    # by combining the 1D and 2D contributions.\n    x_all = collect(Emin:h:Emax)\n    y_1 = zeros(ComplexF64, length(x_all))\n    y_2 = zeros(ComplexF64, length(x_all))","category":"section"},{"location":"#Moment-calculation","page":"Home","title":"Moment calculation","text":"The first step in KPM is calculating moments using Hamiltonians (and current operators for conductivity, etc.). Functions with ! are the more efficient in-place versions; functions without ! are convenient wrappers that call the in-place implementations.","category":"section"},{"location":"#Applications","page":"Home","title":"Applications","text":"","category":"section"},{"location":"#DOS","page":"Home","title":"DOS","text":"To calculate the density of states (DOS) first calculate moments using kpm_1d / kpm_1d! with default (random) input vectors. Then use the returned moments (mu) to evaluate the DOS. There is also a convenience overload that accepts a Hamiltonian directly and performs the moment calculation for you via dos.","category":"section"},{"location":"#Kernels","page":"Home","title":"Kernels","text":"Kernels are functions with signature\n\nkernel(n::Int64, N::Int64) -> Float64\n\nsuch that when n == 0 the kernel returns 1, and when n == N-1 it returns a small number close to 0.\n\nThe package provides the JacksonKernel (the default for most applications) and LorentzKernels.\n\nThe Lorentz kernel is useful for Green's functions because it preserves certain symmetries. LorentzKernels(λ) returns a kernel function parameterized by λ.","category":"section"},{"location":"#API-overview","page":"Home","title":"API overview","text":"Below is a concise list of the main public APIs provided by the package.\n\nMoment / KPM core:\nkpm_1d, kpm_1d!\nkpm_1d_current, kpm_1d_current!\nkpm_2d, kpm_2d!\nkpm_3d, kpm_3d!\nDOS / LDOS:\ndos, dos0\nldos_mu\nConductivity (DC / optical):\nd_dc_cond, dc_cond0, dc_cond_single\noptical_cond1, d_optical_cond1\noptical_cond2, d_optical_cond2\nNonlinear / CPGE:\ncpge, d_cpge\nIntegration helpers: Λnmp, Λn, Λnm, gn_R, gn_A, Δn\nKernels:\nJacksonKernel, LorentzKernels\nUtilities (KPM.Utils / device helpers):\nwrapAdd, normalizeH, isNotBoundary, timestamp\ndevice helpers: whichcore, maybe_to_device, maybe_to_host, maybe_on_device_rand, maybe_on_device_zeros\n\nFor more details see the full API reference below.","category":"section"},{"location":"#KPM.kpm_1d-index","page":"Home","title":"KPM.kpm_1d","text":"kpm_1d(H, NC, NR; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:302.\n\nkpm_1d(\n    H,\n    NC,\n    NR,\n    NH;\n    psi_in,\n    psi_in_l,\n    psi_in_r,\n    force_norm,\n    verbose,\n    avg_output,\n    NR_parallel\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:303.\n\nThe simple version of 1D KPM that returns the moment.\n\nH           – Hamiltonian. A matrix or sparse matrix\nNC          – Integer. the cut off dimension\nNR          – Integer. number of random vectors used for KPM evaluation\nNH          – Integer. the size of hamiltonian\npsi_in      – Optional. Allow setting random vector manually.\nforce_norm  – Boolean, Optional. Apply normalization.\nverbose     – Integer. Default is 0. Enables progress bar if set verbose=1.\navg_output  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_1d!-index","page":"Home","title":"KPM.kpm_1d!","text":"kpm_1d!(H, NC, NR, NH, mu_all, psi_in; verbose, α_all)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:364.\n\nkpm_1d!(H, NC, NR, NH, mu; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:426.\n\nkpm_1d!(H, NC, NR, NH, mu, psi_in_l, psi_in_r; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:435.\n\nThe in-place version of 1D KPM.  Calculate the moments μ defined in KPM. Output is saved in mu.\n\nH           – Hamiltonian. A matrix or sparse matrix.\nNC          – Integer. the cut off dimension.\nNR          – Integer. number of random vectors used for KPM evaluation.\nNH          – Integer. the size of hamiltonian.\nmu_all          – Array. Output for each random vector. Size (NR, NC). \npsi_in      – Array (optional). Input array on the right side. A ket.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_2d-index","page":"Home","title":"KPM.kpm_2d","text":"kpm_2d(\n    H,\n    Jα,\n    Jβ,\n    NC,\n    NR,\n    NH;\n    psi_in,\n    psi_in_l,\n    psi_in_r,\n    arr_size,\n    moment_parity,\n    verbose\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:595.\n\nThe simple version of 2D KPM that returns the moment. Calculate moments for 2D KPM. \n\nCalculates ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.\n\nOutput: μ, a 2D array in ComplexF64. μ[n, m] is the momentum for 2D KPM.\n\nARGS\n\nH\n\nHamiltonian. A sparse 2D array.\n\nJα\n\nCurrent operator. A sparse 2D array.\n\nJβ\n\nCurrent operator. A sparse 2D array.\n\nNC\n\nInteger. KPM cutoff order.\n\nNR\n\nInteger. Number of random vectors to choose from. When skipped, understood as NR=1.\n\nNH\n\nInteger. Dimension of H, Jα and Jβ\n\nKWARGS\n\npsi_in_l\n\nPasses value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in_r\n\nPasses value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in\n\nCannot be used together with psiinl and psiinr. Sets psiinl=psiinr=psi_in if set.\n\nkwargs\n\nother kwargs in KPM_2D!\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_2d!-index","page":"Home","title":"KPM.kpm_2d!","text":"kpm_2d!(\n    H,\n    Jα,\n    Jβ,\n    NC,\n    NR,\n    NH,\n    μ,\n    psi_in_l,\n    psi_in_r;\n    arr_size,\n    verbose,\n    mn_sym,\n    moment_parity,\n    ψ0r,\n    Jψ0r,\n    JTnHJψr,\n    ψall_r,\n    ψ0l,\n    ψall_l,\n    ψw\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:618.\n\nkpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:755.\n\nkpm_2d!(H, Jα, Jβ, NC, NR, NH, μ; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:765.\n\nIn place KPM2D. This is also the main building block for KPM_2D. This method only provide NR=1.\n\nCalculates ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r.  When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is sim O(1sqrt(NR * NH)) with NR repetitions. NC controls the energy resolution of the result.\n\nOutput: nothing. Result is saved on μ.\n\nARGS\n\nH : Hamiltonian. A sparse 2D array.\nJα : Current operator. A sparse 2D array.\nJβ : Current operator. A sparse 2D array.\nNC : Integer. KPM cutoff order.\nNR : Integer. Number of random vectors.\nNH : Integer. Dimension of H, Jα and Jβ\nμ : 2D Array of dimension (NC, NC). Results will be updated here. Any data\n\nwill be overwritten.\n\npsi_in : Set psi_in_l and psi_in_r. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in should be normalized.\n\npsi_in_l : Passes value to ψ0l. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in_l should be normalized. psi_in_l is given as column vector of ket ψl = ψl^dagger\n\npsi_in_r : Passes value to ψ0r. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in_r should be normalized. psi_in_r is given as column vector of ket ψr. \n\nKWARGS\n\narr_size : The buffer array size. Minimum is 3. Determines the number of\n\nleft states to be kept in memory for each loop of right states. The time complexity is reduced from O(Ntimes NC^2) to O(Ntimes NCtimes arr_size) while space complexity is increased from O(Ntimes NC) to O(Ntimes NCtimes arr_size).\n\nmoment_parity : The condition enforced on μmn. Choose from :NONE, :ODD and :EVEN.\n\n:NONE will calculate all μmn; :ODD will calculate μmn such that mod(m+n, 2)==1; :EVEN will calculate μmn such that mod(m+n, 2)==0. As an example, moment_parity=:EVEN can be used when calculating longitudinal conductivity on model with particle-hole symmetry to save time and increase accuracy. \n\nworking spaces KWARGS: The following keyword args are simply providing working place arrays to avoid repetitive allocation and GC. They are automatically created if not set. However, when using KPM_2D! for many times, it is beneficial to reuse those arrays.  CONVENTION: args with ψ are all working space arr.\n\nψ0r=maybe_on_device_zeros(NH, NR)\nJψ0r=maybe_on_device_zeros(NH, NR)\nJTnHJψr=maybe_on_device_zeros(NH, NR)\nψall_r=maybe_on_device_zeros(3, NH, NR)\nψ0l=maybe_on_device_zeros(NH, NR)\nψall_l=maybe_on_device_zeros(arr_size, NH, NR)\nψw=maybe_on_device_zeros(NH, NR)\n\n\n\n\n\n","category":"function"},{"location":"#KPM.dos-index","page":"Home","title":"KPM.dos","text":"dos(\n    H;\n    NC,\n    NR,\n    E_grid,\n    N_tilde,\n    E_range,\n    kernel,\n    fix_normalization,\n    dE_order\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:31.\n\ndos(\n    μ,\n    H_rescale_factor;\n    E_grid,\n    N_tilde,\n    E_range,\n    NC,\n    kernel,\n    dE_order\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:49.\n\nCalculate DOS for a fermi energy grid spanning E_range with N_tilde total points. If E_range is not set,  automatically set it to be sightly smaller than full size. Otherwise an explicit array of E_grid can be passed in. Don't do both.\n\nEither a) pass in a 1d array as moment and  as normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword rescale_factor that default to 1.\n\nH_rescale_factor is the normalization of H. Needed when μ is passed.\nNR random vectors. Needed when H is passed\n\n\n\n\n\n","category":"function"},{"location":"#KPM.JacksonKernel-index","page":"Home","title":"KPM.JacksonKernel","text":"JacksonKernel(n::Integer, N::Integer)\n\nJacksonkernel evaluated at n-th expansion coefficient with N in total (NC)\n\n\n\n\n\n","category":"function"},{"location":"#KPM.LorentzKernels-index","page":"Home","title":"KPM.LorentzKernels","text":"LorentzKernels(λ::Float64)\n\nReturns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)\n\n\n\n\n\n","category":"function"},{"location":"#KPM.JacksonKernel-Tuple{Integer, Integer}","page":"Home","title":"KPM.JacksonKernel","text":"JacksonKernel(n::Integer, N::Integer)\n\nJacksonkernel evaluated at n-th expansion coefficient with N in total (NC)\n\n\n\n\n\n","category":"method"},{"location":"#KPM.Lambda_nm-Tuple{Any, Any, Any}","page":"Home","title":"KPM.Lambda_nm","text":"Lambda_nm is integral of f(Ef)/(1-Ef^2)^2 * Γnm(Ef). Notice that all Ef is scaled to -1 to 1.\n\nδ is the amount around ±1 to avoid.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.LorentzKernels-Tuple{Float64}","page":"Home","title":"KPM.LorentzKernels","text":"LorentzKernels(λ::Float64)\n\nReturns function LorentzKernel(n, N) that evaluates Lorentz kernel with parameter λ, at n-th expansion coefficient with N in total (NC)\n\n\n\n\n\n","category":"method"},{"location":"#KPM.broadcast_dot_1d_1d!","page":"Home","title":"KPM.broadcast_dot_1d_1d!","text":"Vl and Vr are both [NH, NR] sized array. Each corresponding [:, NR] slice pair is dotted, saving into the target of [NR], multiplying by alpha and plus beta. Beta is either a number or vector of [NR]\n\n\n\n\n\n","category":"function"},{"location":"#KPM.broadcast_dot_reduce_avg_2d_1d!-Tuple{Union{SubArray, Array}, Vector{T} where T<:(SubArray{Ts, 2} where Ts), Matrix, Int64, Int64}","page":"Home","title":"KPM.broadcast_dot_reduce_avg_2d_1d!","text":"Dot product each column of Vls with vector Vr, save in target. Each view has NR replica of NH. This function take the average.\n\ntarget: 1D Array (n), n >= NCcols. Vls: 1D Array of 2D views, shape (n), each view (NH, NR), where n >= NCcols. Vr: 2D Array, shape NH, NR NCcols: Integer, number of columns. \n\n\n\n\n\n","category":"method"},{"location":"#KPM.chebyshev_iter-Tuple{Any, Union{Matrix{T}, CUDA.CuArray{T, 2}} where T, Int64}","page":"Home","title":"KPM.chebyshev_iter","text":"evaluate from 3 to n ψall[:,3] comes from ψall[:,2] and ψall[:,1] separating into two function might improve performance (or not???)\n\n\n\n\n\n","category":"method"},{"location":"#KPM.d_dc_cond","page":"Home","title":"KPM.d_dc_cond","text":"d_dc_cond(μ, a, E; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:82.\n\nd_dc_cond(μ, a, E; NC, kernel, dE_order)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:84.\n\nCalculate the integrand for conductivity of an energy grid spanning E_range with N_tilde total points.  If E_range is not set,  automatically set it to be sightly smaller than full size.  Otherwise an explicit array of E_grid can be passed in. Don't do both.\n\nEither a) pass in a 2d array as moment and a normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword rescale_factor that default to 1, as well as two current operators Jα and Jβ\n\nH_rescale_factor is the normalization of H. Needed when μ is passed.\nNR random vectors. Needed when H is passed\n\n\n\n\n\n","category":"function"},{"location":"#KPM.dc_cond0","page":"Home","title":"KPM.dc_cond0","text":"dc_cond0(mu, H_rescale_factor; kernel, NC)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:127.\n\nCalculate DOS and its energy derivatives (by setting dE_order) at zero energy.\n\nWarning: This method does not have correct normalization at the moment. \n\n\n\n\n\n","category":"function"},{"location":"#KPM.dc_cond0-Tuple{Any, Number}","page":"Home","title":"KPM.dc_cond0","text":"calculate conductivity for EF=0. Only works for longitudinal cond. Garcia et. al. Supp eq.25.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.dc_cond_single","page":"Home","title":"KPM.dc_cond_single","text":"dc_cond_single(mu, H_rescale_factor, Ef; kernel, NC)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/conductivity.jl:139.\n\nCalculate DOS at a given energy.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.dc_cond_single-Tuple{Any, Number, Number}","page":"Home","title":"KPM.dc_cond_single","text":"calculate conductivity for arbitrary EF. Only works for longitudinal cond. Garcia et. al. Supp eq.25.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.dos","page":"Home","title":"KPM.dos","text":"dos(\n    H;\n    NC,\n    NR,\n    E_grid,\n    N_tilde,\n    E_range,\n    kernel,\n    fix_normalization,\n    dE_order\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:31.\n\ndos(\n    μ,\n    H_rescale_factor;\n    E_grid,\n    N_tilde,\n    E_range,\n    NC,\n    kernel,\n    dE_order\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:49.\n\nCalculate DOS for a fermi energy grid spanning E_range with N_tilde total points. If E_range is not set,  automatically set it to be sightly smaller than full size. Otherwise an explicit array of E_grid can be passed in. Don't do both.\n\nEither a) pass in a 1d array as moment and  as normalization factor;  or b) pass in a Hamiltonian that is rescaled with an optional keyword rescale_factor that default to 1.\n\nH_rescale_factor is the normalization of H. Needed when μ is passed.\nNR random vectors. Needed when H is passed\n\n\n\n\n\n","category":"function"},{"location":"#KPM.dos0","page":"Home","title":"KPM.dos0","text":"dos0(μ, H_rescale_factor; NC, kernel, dE_order)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/applications/dos.jl:136.\n\nCalculate DOS and its energy derivatives (by setting dE_order) at zero energy.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.fermiFunction-Tuple{Float64, Float64, Float64}","page":"Home","title":"KPM.fermiFunction","text":"fermiFunction(E, E_f, beta)\n\ncalculate Fermi-Dirac function at energy E, Fermi energy μ and temperature β =1/T. Input and output all Float64. Infinite β only allowed when accessing fermi energy through fermiFunctions(). [For performance reason for now. TODO: allow β=Inf here withouth perf. reduction. ]\n\nAllow sloppy use of type as long as convertion is available, if using keyword arguments. \n\n\n\n\n\n","category":"method"},{"location":"#KPM.fermiFunctions-Tuple{Float64, Float64}","page":"Home","title":"KPM.fermiFunctions","text":"fermiFunctions(E_f::Float64, beta::Float64)\n\nreturns a fermi function with given E_f and beta. \n\nAllow sloppy use of type as long as convertion is available, if using keyword arguments. \n\n\n\n\n\n","category":"method"},{"location":"#KPM.gram_schmidt!-Tuple{Any}","page":"Home","title":"KPM.gram_schmidt!","text":"orthonormalize the column vectors of A. In-place.\n\nUsing classical Gram-Schmit.\n\nWhen orthogonality is extremely important, applying the same method twice may help, according to this note.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.gram_schmidt-Tuple{Any}","page":"Home","title":"KPM.gram_schmidt","text":"orthonormalize the column vectors of A. See gram_schmidt!, the in-place version for details.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.isNotBoundary-NTuple{4, Any}","page":"Home","title":"KPM.isNotBoundary","text":"give 0 for OBC=1 direction if i,i_ is on boundary. Otherwise 1\n\n\n\n\n\n","category":"method"},{"location":"#KPM.kpm_1d","page":"Home","title":"KPM.kpm_1d","text":"kpm_1d(H, NC, NR; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:302.\n\nkpm_1d(\n    H,\n    NC,\n    NR,\n    NH;\n    psi_in,\n    psi_in_l,\n    psi_in_r,\n    force_norm,\n    verbose,\n    avg_output,\n    NR_parallel\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:303.\n\nThe simple version of 1D KPM that returns the moment.\n\nH           – Hamiltonian. A matrix or sparse matrix\nNC          – Integer. the cut off dimension\nNR          – Integer. number of random vectors used for KPM evaluation\nNH          – Integer. the size of hamiltonian\npsi_in      – Optional. Allow setting random vector manually.\nforce_norm  – Boolean, Optional. Apply normalization.\nverbose     – Integer. Default is 0. Enables progress bar if set verbose=1.\navg_output  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_1d!","page":"Home","title":"KPM.kpm_1d!","text":"kpm_1d!(H, NC, NR, NH, mu_all, psi_in; verbose, α_all)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:364.\n\nkpm_1d!(H, NC, NR, NH, mu; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:426.\n\nkpm_1d!(H, NC, NR, NH, mu, psi_in_l, psi_in_r; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:435.\n\nThe in-place version of 1D KPM.  Calculate the moments μ defined in KPM. Output is saved in mu.\n\nH           – Hamiltonian. A matrix or sparse matrix.\nNC          – Integer. the cut off dimension.\nNR          – Integer. number of random vectors used for KPM evaluation.\nNH          – Integer. the size of hamiltonian.\nmu_all          – Array. Output for each random vector. Size (NR, NC). \npsi_in      – Array (optional). Input array on the right side. A ket.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_1d_current","page":"Home","title":"KPM.kpm_1d_current","text":"kpm_1d_current(H, Jα, NC, NR; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:445.\n\nkpm_1d_current(\n    H,\n    Jα,\n    NC,\n    NR,\n    NH;\n    psi_in,\n    psi_in_l,\n    psi_in_r,\n    force_norm,\n    verbose,\n    avg_output,\n    NR_parallel\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:446.\n\nThe simple version of 1D KPM with current operator that returns the moment. Calculate moments Γn^α = Tr[Jα T_n(H)].\n\nH           – Hamiltonian. A matrix or sparse matrix\nJα          – Current operator. A matrix or sparse matrix\nNC          – Integer. the cut off dimension\nNR          – Integer. number of random vectors used for KPM evaluation\nNH          – Integer. the size of hamiltonian\npsi_in      – Optional. Allow setting random vector manually.\nforce_norm  – Boolean, Optional. Apply normalization.\nverbose     – Integer. Default is 0. Enables progress bar if set verbose=1.\navg_output  – Boolean. Default is true. Whether to output averaged μ (hence size NC) or separate μs (size NR x NC).\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_1d_current!","page":"Home","title":"KPM.kpm_1d_current!","text":"kpm_1d_current!(\n    H,\n    Jα,\n    NC,\n    NR,\n    NH,\n    mu_all,\n    psi_in;\n    verbose,\n    α_all,\n    Jα_psi\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:507.\n\nkpm_1d_current!(H, Jα, NC, NR, NH, mu; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:570.\n\nkpm_1d_current!(\n    H,\n    Jα,\n    NC,\n    NR,\n    NH,\n    mu,\n    psi_in_l,\n    psi_in_r;\n    kwargs...\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:580.\n\nThe in-place version of 1D KPM with current operator. Calculate the moments μ defined in KPM: Γn^α = Tr[Jα T_n(H)].  Output is saved in mu.\n\nH           – Hamiltonian. A matrix or sparse matrix.\nJα          – Current operator. A matrix or sparse matrix.\nNC          – Integer. the cut off dimension.\nNR          – Integer. number of random vectors used for KPM evaluation.\nNH          – Integer. the size of hamiltonian.\nmu_all      – Array. Output for each random vector. Size (NR, NC). \npsi_in      – Array (optional). Input array on the right side. A ket.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_2d","page":"Home","title":"KPM.kpm_2d","text":"kpm_2d(\n    H,\n    Jα,\n    Jβ,\n    NC,\n    NR,\n    NH;\n    psi_in,\n    psi_in_l,\n    psi_in_r,\n    arr_size,\n    moment_parity,\n    verbose\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:595.\n\nThe simple version of 2D KPM that returns the moment. Calculate moments for 2D KPM. \n\nCalculates ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.\n\nOutput: μ, a 2D array in ComplexF64. μ[n, m] is the momentum for 2D KPM.\n\nARGS\n\nH\n\nHamiltonian. A sparse 2D array.\n\nJα\n\nCurrent operator. A sparse 2D array.\n\nJβ\n\nCurrent operator. A sparse 2D array.\n\nNC\n\nInteger. KPM cutoff order.\n\nNR\n\nInteger. Number of random vectors to choose from. When skipped, understood as NR=1.\n\nNH\n\nInteger. Dimension of H, Jα and Jβ\n\nKWARGS\n\npsi_in_l\n\nPasses value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in_r\n\nPasses value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in\n\nCannot be used together with psiinl and psiinr. Sets psiinl=psiinr=psi_in if set.\n\nkwargs\n\nother kwargs in KPM_2D!\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_2d!","page":"Home","title":"KPM.kpm_2d!","text":"kpm_2d!(\n    H,\n    Jα,\n    Jβ,\n    NC,\n    NR,\n    NH,\n    μ,\n    psi_in_l,\n    psi_in_r;\n    arr_size,\n    verbose,\n    mn_sym,\n    moment_parity,\n    ψ0r,\n    Jψ0r,\n    JTnHJψr,\n    ψall_r,\n    ψ0l,\n    ψall_l,\n    ψw\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:618.\n\nkpm_2d!(H, Jα, Jβ, NC, NR, NH, μ, psi_in; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:755.\n\nkpm_2d!(H, Jα, Jβ, NC, NR, NH, μ; kwargs...)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:765.\n\nIn place KPM2D. This is also the main building block for KPM_2D. This method only provide NR=1.\n\nCalculates ψ0l * Tm(H) * Jβ * Tn(H) * Jα * ψ0r.  When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tm(H) Jβ Tn(H) Jα). The accuracy is sim O(1sqrt(NR * NH)) with NR repetitions. NC controls the energy resolution of the result.\n\nOutput: nothing. Result is saved on μ.\n\nARGS\n\nH : Hamiltonian. A sparse 2D array.\nJα : Current operator. A sparse 2D array.\nJβ : Current operator. A sparse 2D array.\nNC : Integer. KPM cutoff order.\nNR : Integer. Number of random vectors.\nNH : Integer. Dimension of H, Jα and Jβ\nμ : 2D Array of dimension (NC, NC). Results will be updated here. Any data\n\nwill be overwritten.\n\npsi_in : Set psi_in_l and psi_in_r. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in should be normalized.\n\npsi_in_l : Passes value to ψ0l. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in_l should be normalized. psi_in_l is given as column vector of ket ψl = ψl^dagger\n\npsi_in_r : Passes value to ψ0r. Size is (NH, NR). The array is not updated.\n\nWhether the input is normalized or not, it is assumed to be intended. Usually psi_in_r should be normalized. psi_in_r is given as column vector of ket ψr. \n\nKWARGS\n\narr_size : The buffer array size. Minimum is 3. Determines the number of\n\nleft states to be kept in memory for each loop of right states. The time complexity is reduced from O(Ntimes NC^2) to O(Ntimes NCtimes arr_size) while space complexity is increased from O(Ntimes NC) to O(Ntimes NCtimes arr_size).\n\nmoment_parity : The condition enforced on μmn. Choose from :NONE, :ODD and :EVEN.\n\n:NONE will calculate all μmn; :ODD will calculate μmn such that mod(m+n, 2)==1; :EVEN will calculate μmn such that mod(m+n, 2)==0. As an example, moment_parity=:EVEN can be used when calculating longitudinal conductivity on model with particle-hole symmetry to save time and increase accuracy. \n\nworking spaces KWARGS: The following keyword args are simply providing working place arrays to avoid repetitive allocation and GC. They are automatically created if not set. However, when using KPM_2D! for many times, it is beneficial to reuse those arrays.  CONVENTION: args with ψ are all working space arr.\n\nψ0r=maybe_on_device_zeros(NH, NR)\nJψ0r=maybe_on_device_zeros(NH, NR)\nJTnHJψr=maybe_on_device_zeros(NH, NR)\nψall_r=maybe_on_device_zeros(3, NH, NR)\nψ0l=maybe_on_device_zeros(NH, NR)\nψall_l=maybe_on_device_zeros(arr_size, NH, NR)\nψw=maybe_on_device_zeros(NH, NR)\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_3d","page":"Home","title":"KPM.kpm_3d","text":"kpm_3d(\n    H,\n    Jα,\n    Jβ,\n    Jγ,\n    NC,\n    NR,\n    NH;\n    arr_size,\n    verbose,\n    psi_in_l,\n    psi_in_r,\n    psi_in\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:867.\n\nTODO: add doc.\n\n\n\n\n\n","category":"function"},{"location":"#KPM.kpm_3d!","page":"Home","title":"KPM.kpm_3d!","text":"kpm_3d!(\n    H,\n    Jα,\n    Jβ,\n    Jγ,\n    NC,\n    NR,\n    NH,\n    μ,\n    psi_in_l,\n    psi_in_r;\n    arr_size,\n    verbose,\n    ψ0r,\n    JTn1HJψr,\n    ψall_r,\n    ψ0l,\n    sub_ψ0r,\n    sub_Jψ0r,\n    sub_JTnHJψr,\n    sub_ψall_r,\n    sub_ψ0l,\n    sub_ψall_l,\n    sub_ψw\n)\n\ndefined at /home/runner/work/KPMsub.jl/KPMsub.jl/src/moment.jl:781.\n\nThe simple version of tripple KPM that returns the moment. Calculate moments for tripple KPM. \n\nCalculates ψ0l * Tn3(H) * Jγ * Tn2(H) * Jβ * Tn1(H) * Jα * ψ0r. When ψ0r and ψ0l are chosen to be random and identical, the output approximates tr(Tn3(H) Jγ Tn2(H) Jβ Tn1(H) Jα). The accuracy is ~ O(1/sqrt(NR * NH)). NC controls the energy resolution of the result.\n\nOutput: μ, a 3D array in ComplexF64. μ[n3, n2, n1] is the momentum for 2D KPM.\n\nARGS\n\nH\n\nHamiltonian. A sparse 2D array.\n\nJα\n\nCurrent operator. A sparse 2D array.\n\nJβ\n\nCurrent operator. A sparse 2D array.\n\nJγ\n\nCurrent operator. A sparse 2D array.\n\nNC\n\nInteger. KPM cutoff order.\n\nNR\n\nInteger. Number of random vectors to choose from. When skipped, understood as NR=1.\n\nNH\n\nInteger. Dimension of H, Jα, Jβ and Jγ\n\nKWARGS\n\npsi_in_l\n\nPasses value to ψ0l. The array is not updated. Size should be (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in_r\n\nPasses value to ψ0r. The array is not updated. Size should be  (NH, NR) (preferred) or (NR, NH) if set.\n\npsi_in\n\nCannot be used together with psiinl and psiinr. Sets psiinl=psiinr=psi_in if set.\n\nkwargs\n\nother kwargs in KPM_2D!\n\n\n\n\n\n","category":"function"},{"location":"#KPM.mu2D_apply_kernel_and_h_no_mutate-Tuple{Any, Int64, Function}","page":"Home","title":"KPM.mu2D_apply_kernel_and_h_no_mutate","text":"Create μtilde based on mu, by applying both kernel function and hn(n) for each direction.\n\nμtilde is ComplexF64 array.\n\nNo mutate version, takes more memory\n\n\n\n\n\n","category":"method"},{"location":"#KPM.normalizeH-Tuple{Any}","page":"Home","title":"KPM.normalizeH","text":"Normalize H. If requested, allow renormalizing it to fixed value.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.normalize_by_col-Tuple{Any, Any}","page":"Home","title":"KPM.normalize_by_col","text":"Normalize a collection of vectors in an (NH, NR) array psi_in, where each column (that is psi_in[:, NRi]) represent a separate vector.\n\n\n\n\n\n","category":"method"},{"location":"#KPM.wrapAdd-Tuple{Int64, Int64, Int64}","page":"Home","title":"KPM.wrapAdd","text":"wrapAdd find the sum of x and y, with L+1=1\n\n\n\n\n\n","category":"method"},{"location":"#KPM.Γnm-Tuple{Int64, Int64, Any}","page":"Home","title":"KPM.Γnm","text":"Calculate Γnm. Details see Garcia et.al, PRL 114, 116602 (2015)\n\n\n\n\n\n","category":"method"},{"location":"#KPM.Γnmμnmαβ-Tuple{Array, Any, Any}","page":"Home","title":"KPM.Γnmμnmαβ","text":"Calculate Γnmμnmαβ. The input μtilde should be the moment that has already applied kernel and hn\n\n\n\n\n\n","category":"method"},{"location":"#KPM.Λn-Tuple{Any}","page":"Home","title":"KPM.Λn","text":"beta : Inf is zero temperature. beta = 1/T.\nE_f : Fermi energy. Between -1 and 1 because Hamiltonian is normalized. \n\n\n\n\n\n","category":"method"},{"location":"#KPM.Λnmp-Tuple{Any, Any, Any}","page":"Home","title":"KPM.Λnmp","text":"beta : Inf is zero temperature. beta = 1/T.\nE_f : Fermi energy. Between -1 and 1 because Hamiltonian is normalized. \n\n\n\n\n\n","category":"method"}]
}
